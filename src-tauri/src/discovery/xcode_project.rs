use crate::models::project::Scheme;
use std::path::{Path, PathBuf};
use std::process::Command;

/// Discover Xcode project schemes by running `xcodebuild -list -json`,
/// then enrich each scheme with test targets from .xcscheme files.
pub fn discover_schemes(project_path: &str) -> Result<Vec<Scheme>, String> {
    let path = Path::new(project_path);

    let workspace = find_file_with_extension(path, "xcworkspace");
    let project = find_file_with_extension(path, "xcodeproj");

    let mut cmd = Command::new("xcodebuild");
    cmd.arg("-list").arg("-json");

    if let Some(ref ws) = workspace {
        cmd.arg("-workspace").arg(ws);
    } else if let Some(ref proj) = project {
        cmd.arg("-project").arg(proj);
    } else {
        return Ok(vec![]);
    }

    let output = cmd.output().map_err(|e| format!("Failed to run xcodebuild: {}", e))?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        return Err(format!("xcodebuild -list failed: {}", stderr));
    }

    let stdout = String::from_utf8_lossy(&output.stdout);
    let mut schemes = parse_xcodebuild_list(&stdout)?;

    // Fallback test targets when scheme has no .xcscheme (e.g. autogenerated scheme): from project targets
    let project_test_targets = project.as_ref().and_then(|p| {
        let pbxproj = Path::new(p).join("project.pbxproj");
        parse_test_targets_from_pbxproj(&pbxproj).ok()
    }).unwrap_or_default();

    // Enrich each scheme with test targets from .xcscheme, or fall back to project test targets
    for scheme in &mut schemes {
        if let Some(xcscheme_path) = find_xcscheme_path(project_path, &scheme.name, workspace.as_deref(), project.as_deref()) {
            scheme.test_targets = parse_test_targets_from_xcscheme(&xcscheme_path);
        }
        if scheme.test_targets.is_empty() && !project_test_targets.is_empty() {
            scheme.test_targets = project_test_targets.clone();
        }
    }

    Ok(schemes)
}

fn find_file_with_extension(dir: &Path, ext: &str) -> Option<String> {
    if let Ok(entries) = std::fs::read_dir(dir) {
        for entry in entries.flatten() {
            if let Some(e) = entry.path().extension() {
                if e == ext {
                    return Some(entry.path().to_string_lossy().to_string());
                }
            }
        }
    }
    None
}

fn parse_xcodebuild_list(json_str: &str) -> Result<Vec<Scheme>, String> {
    let value: serde_json::Value =
        serde_json::from_str(json_str).map_err(|e| format!("Failed to parse JSON: {}", e))?;

    let mut schemes = Vec::new();

    // Try workspace format first, then project format
    let scheme_names = value
        .get("workspace")
        .and_then(|w| w.get("schemes"))
        .or_else(|| value.get("project").and_then(|p| p.get("schemes")));

    if let Some(serde_json::Value::Array(arr)) = scheme_names {
        for s in arr {
            if let Some(name) = s.as_str() {
                schemes.push(Scheme {
                    name: name.to_string(),
                    test_targets: vec![],
                });
            }
        }
    }

    Ok(schemes)
}

/// Resolve .xcscheme path for a scheme. Checks shared location first, then user-specific (xcuserdata).
fn find_xcscheme_path(
    project_path: &str,
    scheme_name: &str,
    workspace_path: Option<&str>,
    project_path_opt: Option<&str>,
) -> Option<PathBuf> {
    let safe_name = scheme_name.replace(['/', '\\'], "_");
    let filename = format!("{}.xcscheme", safe_name);

    let try_path = |base: &Path| {
        let p = base.join("xcshareddata").join("xcschemes").join(&filename);
        if p.exists() {
            return Some(p);
        }
        // Unshared schemes: xcuserdata/<username>.xcuserdatad/xcschemes/
        let xcuserdata = base.join("xcuserdata");
        if let Ok(entries) = std::fs::read_dir(&xcuserdata) {
            for entry in entries.flatten() {
                let path = entry.path();
                if path.is_dir() && path.extension().is_none() {
                    let xcscheme = path.join("xcschemes").join(&filename);
                    if xcscheme.exists() {
                        return Some(xcscheme);
                    }
                }
            }
        }
        None
    };

    // Workspace shared then user
    if let Some(ws) = workspace_path {
        let base = Path::new(ws);
        if let Some(p) = try_path(base) {
            return Some(p);
        }
    }

    // Project shared then user
    if let Some(proj) = project_path_opt {
        let base = Path::new(proj);
        if let Some(p) = try_path(base) {
            return Some(p);
        }
    }

    // Fallback: scan project dir for any xcodeproj
    let root = Path::new(project_path);
    if let Ok(entries) = std::fs::read_dir(root) {
        for entry in entries.flatten() {
            let p = entry.path();
            if p.extension().is_some_and(|e| e == "xcodeproj") {
                if let Some(xcscheme) = try_path(&p) {
                    return Some(xcscheme);
                }
            }
        }
    }

    None
}

/// Parse test target names from .xcscheme XML (TestableReference â†’ BuildableReference BlueprintName).
fn parse_test_targets_from_xcscheme(xcscheme_path: &Path) -> Vec<String> {
    let content = match std::fs::read_to_string(xcscheme_path) {
        Ok(c) => c,
        Err(_) => return vec![],
    };

    // Primary: <TestableReference ...> ... <BuildableReference ... BlueprintName="TargetName" ...
    let re = match regex::Regex::new(r#"<TestableReference[\s\S]*?<BuildableReference[\s\S]*?BlueprintName="([^"]+)""#) {
        Ok(r) => r,
        Err(_) => return vec![],
    };
    let mut names: Vec<String> = re
        .captures_iter(&content)
        .filter_map(|cap| cap.get(1).map(|m| m.as_str().to_string()))
        .collect();

    // Fallback: any BlueprintName inside a TestableReference block (in case BuildableReference spans many lines)
    if names.is_empty() {
        // Split by TestableReference and find BlueprintName in each block
        let block_re = match regex::Regex::new(r#"<TestableReference[^>]*>([\s\S]*?)(?:</TestableReference>|$)"#) {
            Ok(r) => r,
            Err(_) => return vec![],
        };
        let blueprint_re = match regex::Regex::new(r#"BlueprintName="([^"]+)""#) {
            Ok(r) => r,
            Err(_) => return vec![],
        };
        for block_cap in block_re.captures_iter(&content) {
            if let Some(block) = block_cap.get(1) {
                for name_cap in blueprint_re.captures_iter(block.as_str()) {
                    if let Some(m) = name_cap.get(1) {
                        names.push(m.as_str().to_string());
                    }
                }
            }
        }
    }

    names.dedup();
    names
}

/// When there is no .xcscheme (autogenerated scheme), get test target names from project.pbxproj
/// by finding PBXNativeTarget entries with unit-test or ui-testing product type.
fn parse_test_targets_from_pbxproj(pbxproj_path: &Path) -> Result<Vec<String>, String> {
    let content = std::fs::read_to_string(pbxproj_path)
        .map_err(|e| format!("Failed to read project.pbxproj: {}", e))?;

    let mut names = Vec::new();
    // Split into PBXNativeTarget blocks (from "= {" after isa = PBXNativeTarget to "};")
    let block_re = regex::Regex::new(r"isa = PBXNativeTarget;([\s\S]*?)\n\t\t};")
        .map_err(|e| format!("Regex error: {}", e))?;
    let name_re = regex::Regex::new(r"name = ([^;]+);")
        .map_err(|e| format!("Regex error: {}", e))?;
    let product_type_re = regex::Regex::new(r#"productType = "([^"]+)";"#)
        .map_err(|e| format!("Regex error: {}", e))?;

    for block_cap in block_re.captures_iter(&content) {
        let block = block_cap.get(1).map(|m| m.as_str()).unwrap_or("");
        let product_type = product_type_re
            .captures(block)
            .and_then(|c| c.get(1))
            .map(|m| m.as_str());
        let is_test = product_type
            .map(|t| {
                t == "com.apple.product-type.bundle.unit-test"
                    || t == "com.apple.product-type.bundle.ui-testing"
            })
            .unwrap_or(false);
        if is_test {
            if let Some(name_cap) = name_re.captures(block) {
                if let Some(m) = name_cap.get(1) {
                    let name = m.as_str().trim().to_string();
                    if !name.is_empty() {
                        names.push(name);
                    }
                }
            }
        }
    }
    names.dedup();
    Ok(names)
}
